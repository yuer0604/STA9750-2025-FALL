---
title: "How Well Does Film Activity Predict Housing Prices in NYC?"
author: "Yu Yang"
date: "December 14, 2025"
format:
  html:
    code-fold: true
    code-summary: "Show code"
---
# Introduction & Motivation

New York City is one of the most important locations for film and television production in the United States. Film activity is very visible in the city and often concentrates in specific neighborhoods. These neighborhoods are usually transit-accessible, visually attractive, or culturally well known. Because of this, film production is often discussed as a possible signal of neighborhood change, such as increasing desirability and rising housing prices. However, it is not clear whether film activity actually predicts housing price changes, or if it simply follows existing economic patterns.

Previous research and public reports often describe film production as an economic driver. They focus on its impact on jobs, local businesses, and urban development. At the same time, academic studies on creative industries suggest that film activity may not cause neighborhood change directly. Instead, it may appear more often in neighborhoods that are already experiencing economic growth or gentrification. This difference is important, especially in New York City, where housing affordability and inequality are major issues.

This project addresses the following research question: How well does film activity perform as a predictor of housing prices, compared to traditional economic factors such as income and rent? To explore this question, I analyze NYC property sales data from 2013 to 2023 and combine it with ZIP-code–level data from the American Community Survey, including median household income and median monthly rent. Film production patterns are based on permit data analyzed earlier in the group project, which identifies production hotspots and changes in filming activity over time.

Instead of analyzing film activity alone, this report places it within a broader economic context. By comparing housing prices with income and rent across ZIP codes and boroughs, this analysis evaluates whether film activity adds meaningful information beyond traditional economic indicators. The goal of this study is not to claim that film production causes housing price changes, but to understand whether film activity acts as an early signal of neighborhood change or mainly reflects existing economic conditions.

# Data Acquisition

This project uses multiple public datasets to analyze the relationship between film activity, housing prices, and economic conditions in New York City. All data were collected and processed using R to ensure reproducibility.

The housing price data come from the New York City Department of Finance Annualized Property Sales files. These datasets contain individual property sale records for each borough. The data cover the years from 2013 to 2023 and include information such as sale price, sale date, borough, neighborhood, address, and ZIP code. The raw files were downloaded directly from the NYC government website and stored locally using automated R scripts. This approach ensures that the same data can be re-downloaded and verified in the future.

To measure economic conditions, I use data from the American Community Survey (ACS) 5-year estimates, accessed through the tidycensus package in R. Two economic variables are collected at the ZIP Code Tabulation Area (ZCTA) level: median household income and median monthly rent. These variables are commonly used indicators of neighborhood economic status. The ACS data cover the same time period as the housing sales data, from 2013 to 2023, excluding 2020 due to survey disruptions.

Film production activity is represented using NYC film permit data analyzed earlier in the group project. These data identify where and how frequently filming occurs across neighborhoods and over time. While film permit density is not directly merged into every visualization in this individual report, it provides important contextual information for interpreting spatial and temporal patterns observed in housing prices.

All datasets are filtered to include only ZIP codes located within the five boroughs of New York City. Using ZIP codes as a common geographic unit allows housing prices and economic indicators to be compared consistently across space and time.

```{r}
#| echo: true
#| message: false
#| warning: false
#| results: hide

# ---- Setup download directory ----
library(readxl)
library(dplyr)
library(janitor)

data_dir <- "data/property_sales_raw"
dir.create(data_dir, recursive = TRUE, showWarnings = FALSE)

base_url <- "https://www.nyc.gov/assets/finance/downloads/pdf/rolling_sales/annualized-sales"

years    <- 2013:2023
boroughs <- c("bronx", "brooklyn", "manhattan", "queens", "statenisland")

# Helper to try one URL and return success TRUE/FALSE
safe_download <- function(url, dest) {
  status <- tryCatch(
    download.file(url, destfile = dest, mode = "wb", quiet = TRUE),
    error = function(e) 1L
  )
  is.numeric(status) && status == 0L
}

# ---- Function to download one file ----
download_one_file <- function(year, borough) {
  # pick correct borough slug for the filename
  borough_slug <- borough
  if (borough == "statenisland" && year >= 2020) {
    borough_slug <- "staten_island"   # 2020+ files use underscore
  }

  # older years = .xls, newer years = .xlsx
  if (year <= 2017) {
    exts <- c("xls", "xlsx")
  } else {
    exts <- c("xlsx", "xls")
  }

  for (ext in exts) {
    url  <- sprintf("%s/%d/%d_%s.%s", base_url, year, year, borough_slug, ext)
    dest <- file.path(data_dir, sprintf("%d_%s.%s", year, borough_slug, ext))

    message("Trying: ", url)

    if (safe_download(url, dest)) {
      message("  ✓ downloaded: ", dest)
      return(dest)
    } else {
      message("  ✗ failed for: ", url)
    }
  }

  warning("Could not download file for ", year, " / ", borough)
  NA_character_
}


# ---- Download ALL 2013–2023 files ----
files <- unlist(
  lapply(years, function(y) {
    sapply(boroughs, download_one_file, year = y, simplify = TRUE)
  })
)

# keep only successful downloads
files <- files[!is.na(files)]

# Quick check: which years did we actually download?
download_years <- table(substr(basename(files), 1, 4))
print(download_years)

# ---- Read and combine ----
# ---- Read and combine (using BOROUGH row as header) ----
library(readxl)
library(dplyr)
library(janitor)

sales_list <- lapply(files, function(f) {

  # read everything as text, no column names yet
  raw <- read_excel(
    path      = f,
    col_names = FALSE,
    col_types = "text"
  )

  # find the row that contains the real header ("BOROUGH ...")
  header_row <- which(raw[[1]] == "BOROUGH")
  if (length(header_row) == 0L) {
    header_row <- which(grepl("BOROUGH", raw[[1]]))[1]
  }
  if (is.na(header_row)) {
    stop("Could not find header row in file: ", f)
  }

  # use that row as column names, data starts on the next row
  header <- as.character(unlist(raw[header_row, ]))
  df <- raw[(header_row + 1):nrow(raw), ]
  names(df) <- header

  # drop completely empty rows/cols
  df <- df %>%
    remove_empty("rows") %>%
    remove_empty("cols")

  # add year from file name (e.g. "2019_bronx.xlsx")
  name <- basename(f)
  year <- as.numeric(substr(name, 1, 4))
  df$year <- year

  df
})

sales_2013_2023 <- bind_rows(sales_list)

```

```{r}
#| echo: true
#| message: false
#| warning: false
#| results: hide


library(dplyr)
library(janitor)

# ---- Split into 3 format groups ----
sales_raw_2013_2017 <- sales_2013_2023 %>%
  filter(year >= 2013, year <= 2017)

sales_raw_2018_2019 <- sales_2013_2023 %>%
  filter(year >= 2018, year <= 2019)

sales_raw_2020_2023 <- sales_2013_2023 %>%
  filter(year >= 2020, year <= 2023)

# ---- Quick checks ----
message("Check years in each split:")
print(table(sales_raw_2013_2017$year))
print(table(sales_raw_2018_2019$year))
print(table(sales_raw_2020_2023$year))

message("Row counts:")
nrow(sales_raw_2013_2017)
nrow(sales_raw_2018_2019)
nrow(sales_raw_2020_2023)

message("Column counts (should be similar within each group):")
ncol(sales_raw_2013_2017)
ncol(sales_raw_2018_2019)
ncol(sales_raw_2020_2023)

```

```{r}
#| echo: true
#| message: false
#| warning: false
#| results: hide

clean_2013_2017 <- function(df) {
  df %>%
    clean_names() %>%
    filter(borough %in% c("1","2","3","4","5")) %>%
    mutate(
      borough = case_when(
        borough == "1" ~ "Manhattan",
        borough == "2" ~ "Bronx",
        borough == "3" ~ "Brooklyn",
        borough == "4" ~ "Queens",
        borough == "5" ~ "Staten Island"
      ),
      sale_price = suppressWarnings(as.numeric(gsub("[^0-9]", "", sale_price))),
      sale_date  = suppressWarnings(as.Date(as.numeric(sale_date), origin = "1899-12-30"))
    ) %>%
    filter(!is.na(sale_price), sale_price > 10000) %>%
    select(year, borough, neighborhood, address, zip_code, sale_price, sale_date) %>%
    arrange(year, borough, sale_date)
}

sales_clean_2013_2017 <- clean_2013_2017(sales_raw_2013_2017)

# ---- Quick checks ----
message("2013-2017 cleaned:")
summary(sales_clean_2013_2017$sale_price)
range(sales_clean_2013_2017$sale_date, na.rm = TRUE)
head(sales_clean_2013_2017)

```

```{r}
#| echo: true
#| message: false
#| warning: false
#| results: hide

library(dplyr)
library(janitor)
library(stringr)
library(lubridate)

clean_2018_2019 <- function(df) {

  df %>%
    clean_names() %>%
    
    # Merge duplicate columns
    mutate(
      borough_code_raw = coalesce(borough, borough_2, borough_3),
      neighborhood_raw = coalesce(neighborhood, neighborhood_2, neighborhood_3),
      address_raw      = coalesce(address, address_2, address_3),
      zip_code_raw     = coalesce(zip_code, zip_code_2, zip_code_3),
      sale_price_raw   = coalesce(sale_price, sale_price_2, sale_price_3),
      sale_date_raw    = coalesce(sale_date, sale_date_2, sale_date_3)
    ) %>%
    
    # Borough code -> name
    mutate(
      borough_code_raw = trimws(borough_code_raw),
      borough = case_when(
        borough_code_raw == "1" ~ "Manhattan",
        borough_code_raw == "2" ~ "Bronx",
        borough_code_raw == "3" ~ "Brooklyn",
        borough_code_raw == "4" ~ "Queens",
        borough_code_raw == "5" ~ "Staten Island",
        TRUE ~ NA_character_
      )
    ) %>%
    filter(!is.na(borough)) %>%
    
    # Clean price
    mutate(
      sale_price = suppressWarnings(as.numeric(gsub("[^0-9]", "", sale_price_raw)))
    ) %>%
    
    # ---- Robust date parsing ----
    mutate(
      # Try numeric Excel serial first
      sale_date_num = suppressWarnings(as.numeric(sale_date_raw)),
      date_from_num = suppressWarnings(as.Date(sale_date_num, origin = "1899-12-30")),

      # Try character dates (mdy, ymd)
      date_from_char = suppressWarnings(parse_date_time(sale_date_raw, orders = c("mdy", "ymd"))),

      # Final date = numeric first, otherwise character-parsed
      sale_date = coalesce(date_from_num, date_from_char)
    ) %>%
    
    filter(!is.na(sale_price), sale_price > 10000, !is.na(sale_date)) %>%
    
    transmute(
      year,
      borough,
      neighborhood = neighborhood_raw,
      address      = address_raw,
      zip_code     = zip_code_raw,
      sale_price,
      sale_date
    ) %>%
    arrange(year, borough, sale_date)
}

```

```{r}
#| echo: true
#| message: false
#| warning: false
#| results: hide

library(dplyr)
library(janitor)
library(stringr)
library(lubridate)

clean_2020_2023 <- function(df) {

  df %>%
    clean_names() %>%

    # 1) Merge the duplicate columns (_2, _3) into one main set
    mutate(
      borough_code_raw = coalesce(borough, borough_2, borough_3),
      neighborhood_raw = coalesce(neighborhood, neighborhood_2, neighborhood_3),
      address_raw      = coalesce(address, address_2, address_3),
      zip_code_raw     = coalesce(zip_code, zip_code_2, zip_code_3),
      sale_price_raw   = coalesce(sale_price, sale_price_2, sale_price_3),
      sale_date_raw    = coalesce(sale_date, sale_date_2, sale_date_3)
    ) %>%

    # 2) Borough code -> borough name
    mutate(
      borough_code_raw = trimws(borough_code_raw),
      borough = case_when(
        borough_code_raw == "1" ~ "Manhattan",
        borough_code_raw == "2" ~ "Bronx",
        borough_code_raw == "3" ~ "Brooklyn",
        borough_code_raw == "4" ~ "Queens",
        borough_code_raw == "5" ~ "Staten Island",
        TRUE ~ NA_character_
      )
    ) %>%
    filter(!is.na(borough)) %>%

    # 3) Clean sale price
    mutate(
      sale_price = suppressWarnings(
        as.numeric(gsub("[^0-9]", "", sale_price_raw))
      )
    ) %>%

    # 4) Robust date parsing (Excel numbers + various text formats)
    mutate(
      sale_date_num  = suppressWarnings(as.numeric(sale_date_raw)),
      date_from_num  = suppressWarnings(as.Date(sale_date_num, origin = "1899-12-30")),
      date_from_char = suppressWarnings(
        parse_date_time(sale_date_raw, orders = c("ymd", "mdy", "dmy"))
      ),
      sale_date      = coalesce(date_from_num, date_from_char)
    ) %>%

    # 5) Keep only reasonable, non-missing sales
    filter(
      !is.na(sale_price),
      sale_price > 10000,
      !is.na(sale_date)
    ) %>%

    # 6) Final columns in same format as other years
    transmute(
      year,
      borough,
      neighborhood = neighborhood_raw,
      address      = address_raw,
      zip_code     = zip_code_raw,
      sale_price,
      sale_date    = as.Date(sale_date)
    ) %>%
    arrange(year, borough, sale_date)
}

```


```{r}
#| echo: true
#| message: false
#| warning: false
#| results: hide
# Create cleaned tables for each period
sales_clean_2013_2017 <- clean_2013_2017(sales_raw_2013_2017)
sales_clean_2018_2019 <- clean_2018_2019(sales_raw_2018_2019)
sales_clean_2020_2023 <- clean_2020_2023(sales_raw_2020_2023)
```


```{r}
#| echo: true
#| message: false
#| warning: false
#| results: hide

library(dplyr)

# Make sure sale_date is Date in every piece
sales_clean_2013_2017 <- sales_clean_2013_2017 %>%
  mutate(sale_date = as.Date(sale_date))

sales_clean_2018_2019 <- sales_clean_2018_2019 %>%
  mutate(sale_date = as.Date(sale_date))

sales_clean_2020_2023 <- sales_clean_2020_2023 %>%
  mutate(sale_date = as.Date(sale_date))

# ---- Combine all years 2013–2023 ----
sales_clean_2013_2023 <- bind_rows(
  sales_clean_2013_2017,
  sales_clean_2018_2019,
  sales_clean_2020_2023
) %>%
  arrange(year, borough, sale_date)

# ---- Final quick checks ----
message("Combined 2013–2023:")
print(table(sales_clean_2013_2023$year))

range(sales_clean_2013_2023$sale_date, na.rm = TRUE)
summary(sales_clean_2013_2023$sale_price)

head(sales_clean_2013_2023)
tail(sales_clean_2013_2023)
```


```{r}
#| echo: true
#| message: false
#| warning: false
#| results: hide

if(!dir.exists(file.path("data", "finalproject"))){
  dir.create(file.path("data", "finalproject"), showWarnings=FALSE, recursive=TRUE)
}

library <- function(pkg){
  ## Mask base::library() to automatically install packages if needed
  ## Masking is important here so downlit picks up packages and links
  ## to documentation
  pkg <- as.character(substitute(pkg))
  options(repos = c(CRAN = "https://cloud.r-project.org"))
  if(!require(pkg, character.only=TRUE, quietly=TRUE)) install.packages(pkg)
  stopifnot(require(pkg, character.only=TRUE, quietly=TRUE))
}

library(tidyverse)
library(glue)
library(readxl)
library(tidycensus)

get_acs_all_years <- function(variable, geography="zcta",
                              start_year=2013, end_year=2023){
  fname <- glue("{variable}_{geography}_{start_year}_{end_year}.csv")
  fname <- file.path("data", "finalproject", fname)
  
  if(!file.exists(fname)){
    YEARS <- seq(start_year, end_year)
    YEARS <- YEARS[YEARS != 2020] # Drop 2020 - No survey (covid)
    
    ALL_DATA <- map(YEARS, function(yy){
      tidycensus::get_acs(geography, variable, year=yy, survey="acs5") |>
        mutate(year=yy) |>
        select(-moe, -variable) |>
        rename(!!variable := estimate)
    }) |> bind_rows()
    
    write_csv(ALL_DATA, fname)
  }
  
  read_csv(fname, show_col_types=FALSE)
}

NYC_ZCTAS <- c(
  # Bronx (005)
  "10451", "10452", "10453", "10454", "10455", "10456", "10457", "10458", 
  "10459", "10460", "10461", "10462", "10463", "10464", "10465", "10466", 
  "10467", "10468", "10469", "10470", "10471", "10472", "10473", "10474", 
  "10475",
  # Brooklyn (047) - Kings County
  "11201", "11203", "11204", "11205", "11206", "11207", "11208", "11209", 
  "11210", "11211", "11212", "11213", "11214", "11215", "11216", "11217", 
  "11218", "11219", "11220", "11221", "11222", "11223", "11224", "11225", 
  "11226", "11228", "11229", "11230", "11231", "11232", "11233", "11234", 
  "11235", "11236", "11237", "11238", "11239",
  # Manhattan (061) - New York County
  "10001", "10002", "10003", "10004", "10005", "10006", "10007", "10009", 
  "10010", "10011", "10012", "10013", "10014", "10016", "10017", "10018", 
  "10019", "10020", "10021", "10022", "10023", "10024", "10025", "10026", 
  "10027", "10028", "10029", "10030", "10031", "10032", "10033", "10034", 
  "10035", "10036", "10037", "10038", "10039", "10040", "10044",
  # Queens (081)
  "11101", "11102", "11103", "11104", "11105", "11106", "11354", "11355", 
  "11356", "11357", "11358", "11360", "11361", "11362", "11363", "11364", 
  "11365", "11366", "11367", "11368", "11369", "11370", "11371", "11372", 
  "11373", "11374", "11375", "11377", "11378", "11379", "11385", "11411", 
  "11412", "11413", "11414", "11415", "11416", "11417", "11418", "11419", 
  "11420", "11421", "11422", "11423", "11426", "11427", "11428", "11429", 
  "11432", "11433", "11434", "11435", "11436", "11691", "11692", "11693", 
  "11694", "11695", "11697",
  # Staten Island (085) - Richmond County
  "10301", "10302", "10303", "10304", "10305", "10306", "10307", "10308", 
  "10309", "10310", "10311", "10312", "10314"
)
# Household income (12 month)
INCOME <- get_acs_all_years("B19013_001") |>
  rename(household_income = B19013_001)
INCOME <- INCOME |>
  filter(GEOID %in% NYC_ZCTAS)

# Monthly rent
RENT <- get_acs_all_years("B25064_001") |>
  rename(monthly_rent = B25064_001)
RENT  <- RENT  |>
  filter(GEOID %in% NYC_ZCTAS)

# Combine tables
JOIN_TABLE <- INCOME |>
  left_join(RENT, by = c("GEOID", "year","NAME" )) |>
  rename(zipcode = "GEOID") |>
  select(-NAME)

## optional function to format the column name
format_titles <- function(df){
  colnames(df) <- str_replace_all(colnames(df), "_", " ") |> str_to_title()
  df
}
JOIN_TABLE |> 
  format_titles()

```

# Data Processing & Methodology

In this section, I describe how the raw datasets were cleaned, transformed, and prepared for analysis. Property sales data were collected from the New York City Department of Finance for all five boroughs and combined across multiple years. These records include detailed information on individual housing transactions, such as sale price, sale date, borough, and ZIP code. To support consistent analysis across time and space, key variables were created, including sale year, ZIP code identifiers, and average housing sale prices.

Before analysis, the raw data were cleaned to remove missing or invalid values and to ensure consistent variable naming across years. Sale dates were converted into numeric year values, and ZIP codes were standardized as character variables to support reliable joins across datasets. Housing prices were then summarized at the ZIP–year level by calculating average and median sale prices. This aggregation reduces noise from individual transactions while preserving meaningful variation across neighborhoods and over time.

To capture local economic conditions, median household income and median monthly rent data were obtained from the American Community Survey (ACS) 5-year estimates. These economic variables were matched to the housing data using ZIP code and year as shared identifiers. This matching process allows housing prices to be directly compared with neighborhood-level economic characteristics at a fine geographic scale. All datasets were restricted to ZIP codes within New York City and to the period from 2013 to 2023 to maintain consistency across analyses.

Film production data analyzed earlier in the group project were not directly merged into the regression models due to differences in data structure and aggregation level. However, these data provide important contextual information for interpreting spatial and temporal patterns in housing prices. Overall, this data processing approach emphasizes reproducibility, transparency, and comparability while balancing analytical detail and interpretability.

# Results & Visualization Analysis

## Income vs. Housing Prices

The first visualization examines the relationship between median household income and average housing sale prices at the ZIP-code level from 2013 to 2023. Each point in the scatterplot represents a ZIP–year observation, and the points are colored by borough. Linear trend lines are added for each borough to highlight overall patterns.

Overall, the plot shows a positive relationship between household income and housing prices, meaning that ZIP codes with higher incomes tend to have higher average sale prices. However, the strength of this relationship varies across boroughs. Manhattan shows consistently higher prices even at similar income levels, while boroughs such as Queens and Staten Island display lower price ranges and more compact clusters.

Importantly, the scatterplot also shows substantial dispersion, especially at mid-income levels. Many ZIP codes with similar income values have very different housing prices. This suggests that income alone does not fully explain housing price variation in New York City. Other neighborhood characteristics—such as location, accessibility, amenities, and historical desirability—likely play an important role.

This visualization provides a baseline comparison for evaluating whether film activity adds additional explanatory power beyond traditional economic indicators like income.

## Rent vs. Housing Prices

The second visualization focuses on the relationship between median monthly rent and average housing sale prices, again at the ZIP–year level and separated by borough. Similar to the income plot, each point represents a ZIP–year observation, with linear trend lines shown for each borough.

Compared to income, rent appears to have a slightly stronger and more consistent association with housing prices, particularly in Manhattan and Brooklyn. In these boroughs, higher rents are more clearly aligned with higher sale prices. This is expected, as rent reflects more immediate housing market conditions and demand pressures.

However, even in this plot, there is still considerable variation within boroughs. Some ZIP codes with relatively moderate rents exhibit high sale prices, while others with higher rents do not experience proportionally higher prices. This again indicates that while rent is a useful predictor, it does not fully capture all drivers of housing prices.

Together, these two visualizations show that traditional economic variables explain part—but not all—of the variation in housing prices. This motivates the need to compare their predictive strength formally and to consider whether film activity may serve as an additional signal of neighborhood desirability.


```{r}
#| echo: true
#| message: false
#| warning: false
#| results: hide

library(dplyr)
library(ggplot2)
library(lubridate)
library(tidyr)
library(scales)

sales_zip_year <- sales_clean_2013_2023 %>%
  # make sure year is from sale_date
  mutate(
    year     = year(sale_date),
    zip_code = as.character(zip_code)
  ) %>%
  group_by(borough, zip_code, year) %>%
  summarise(
    avg_price = mean(sale_price, na.rm = TRUE),
    median_price = median(sale_price, na.rm = TRUE),
    n_sales = n(),
    .groups = "drop"
  ) %>%
  rename(zipcode = zip_code)  # match JOIN_TABLE column name

head(sales_zip_year)

model_df <- sales_zip_year %>%
  inner_join(JOIN_TABLE, by = c("zipcode", "year"))

head(model_df)

ggplot(model_df,
       aes(x = household_income,
           y = avg_price,
           color = borough)) +
  geom_point(alpha = 0.5, size = 1.6) +
  geom_smooth(method = "lm", se = FALSE, linewidth = 0.9) +
  scale_x_continuous(labels = label_dollar()) +
  scale_y_continuous(labels = label_dollar()) +
  coord_cartesian(ylim = c(0, 3000000)) +   # ← zoom to meaningful range
  labs(
    title = "Income vs. Average Housing Prices by ZIP (2013–2023)",
    subtitle = "Each point is a ZIP–year; linear trend shown by borough",
    x = "Median Household Income (ACS)",
    y = "Average Sale Price",
    color = "Borough"
  ) +
  theme_minimal(base_size = 12)

ggplot(model_df,
       aes(x = monthly_rent,
           y = avg_price,
           color = borough)) +
  geom_point(alpha = 0.5, size = 1.6) +
  geom_smooth(method = "lm", se = FALSE, linewidth = 0.9) +
  scale_x_continuous(labels = label_dollar()) +
  scale_y_continuous(labels = label_dollar()) +
  coord_cartesian(ylim = c(0, 3000000)) +   # ← prevents compression
  labs(
    title = "Rent vs. Average Housing Prices by ZIP (2013–2023)",
    subtitle = "Each point is a ZIP–year; linear trend shown by borough",
    x = "Median Monthly Rent (ACS)",
    y = "Average Sale Price",
    color = "Borough"
  ) +
  theme_minimal(base_size = 12)

```


## Regression Model Comparison

To complement the visual analysis, I estimated three linear regression models predicting average housing sale price:

1.Income model: housing prices explained by median household income and borough

2.Rent model: housing prices explained by median monthly rent and borough

3.Combined model: housing prices explained by both income, rent, and borough

Borough fixed effects are included in all models to control for systematic differences across New York City’s five boroughs.

Model performance is evaluated using R² and adjusted R², which measure the proportion of variation in housing prices explained by each model. Higher values indicate better model fit.

The results show that the income-only model explains a meaningful but limited portion of housing price variation. The rent-only model performs slightly better, which is consistent with the stronger relationship observed in the rent-based scatterplots. The combined model provides the highest explanatory power, suggesting that income and rent capture overlapping but distinct aspects of housing market dynamics.

However, even the combined model leaves a substantial amount of variation unexplained. This indicates that economic indicators alone are not sufficient to fully describe housing price patterns in New York City. Importantly, these results provide a useful benchmark for interpreting film activity. Since even core economic variables such as income and rent explain only a modest share of housing price variation, any relationship between film activity and housing prices is likely to be indirect and contextual rather than strongly causal.

These regression models do not include film permit density directly due to differences in data structure and aggregation levels. Instead, income and rent are used as baseline economic predictors to help contextualize the role of film activity discussed in the visual analysis.
```{r}
#| echo: false
#| message: false
#| warning: false

library(broom)
library(knitr)
library(dplyr)

# Model 1: income only
m_income <- lm(avg_price ~ household_income + borough, data = model_df)

# Model 2: rent only
m_rent   <- lm(avg_price ~ monthly_rent + borough, data = model_df)

# Model 3: income + rent together
m_both   <- lm(avg_price ~ household_income + monthly_rent + borough, data = model_df)

model_compare <- tibble(
  model = c("Income + borough", "Rent + borough", "Income + Rent + borough"),
  r2    = c(summary(m_income)$r.squared,
            summary(m_rent)$r.squared,
            summary(m_both)$r.squared),
  adj_r2 = c(summary(m_income)$adj.r.squared,
             summary(m_rent)$adj.r.squared,
             summary(m_both)$adj.r.squared)
)

kable(model_compare, digits = 3,
      caption = "Model comparison (higher R² / Adj-R² = better fit)")
```

# Connection to Film Activity & Summary of Findings

Although film permit density was not directly included as a predictor variable in the regression models, the results provide important context for interpreting the patterns of film activity observed earlier in this project. The limited explanatory power of income and rent suggests that housing prices in New York City are influenced by broader neighborhood factors beyond standard economic indicators.

Film production tends to concentrate in communities that are already attractive or undergoing social and economic transformation. As a result, film activity may not directly cause housing price increases, but instead act as an early signal or reflection of neighborhood change. This interpretation is consistent with prior research and with the spatial clustering and hotspot analyses presented earlier in the project.

Earlier visual analyses show that film activity is spatially concentrated in higher-income and higher-price neighborhoods, particularly in established or emerging cultural areas. When considered together with the regression results, these findings suggest that film activity aligns with existing economic and cultural momentum rather than independently driving housing price changes.

Overall, film production appears to function more as an indicator of neighborhood desirability than as a primary driver of housing market outcomes.

# Limitations & Future Work

This analysis has several limitations that should be acknowledged.

First, film permit density was not directly included as an explanatory variable in the regression models. This is mainly due to differences in data structure and aggregation levels between film permit records and housing price data. As a result, the regression analysis focuses on income and rent as baseline economic predictors, while film activity is examined primarily through spatial and visual analysis. This limits the ability to make direct statistical claims about the causal impact of film production on housing prices.

Second, the regression models explain only a modest portion of the total variation in housing prices. This suggests that many important factors influencing housing prices are not captured in the models. These may include neighborhood amenities, school quality, zoning policies, development projects, access to transportation, and broader macroeconomic conditions. Housing markets in New York City are complex, and linear models with limited predictors cannot fully represent this complexity.

Third, this study relies on average housing prices aggregated at the ZIP–year level. While this approach allows for consistent comparison across time and space, it may mask important within-ZIP variation and short-term price dynamics. Additionally, film activity may affect neighborhoods unevenly within ZIP codes, which cannot be captured using aggregated data.

Future research could address these limitations in several ways. First, film permit data could be more directly integrated into regression models by developing consistent spatial and temporal aggregation methods. Second, additional neighborhood-level variables, such as demographic change, commercial development, or transit investment, could be included to improve explanatory power. Finally, alternative modeling approaches, such as fixed-effects panel models or spatial regression methods, may better capture the localized and dynamic nature of housing markets and film activity in New York City.



