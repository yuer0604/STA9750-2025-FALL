---
title: "Mini Project #02: Making Backyards Affordable for All"
author: "Yu Yang"
format:
  html:
    theme: cosmo
    mainfont: "Lora"
    embed-resources: true
    code-fold: true
    code-summary: "Show code"
execute:
  echo: true
  warning: false
  message: false
---

```{r}
#| include: false
if(!dir.exists(file.path("data", "mp02"))){
  dir.create(file.path("data", "mp02"), showWarnings=FALSE, recursive=TRUE)
}

library(tidyverse)
library(glue)
library(readr)   
library(readxl)
library(tidycensus)
```



## Data Verification Preview

The datasets used in this project come from the U.S. Census Bureau’s American Community Survey (ACS) and the HUD Building Permits Survey. They include information on population, income, rent, household size, and housing permits for U.S. metropolitan areas (CBSAs) from 2009 to 2023. These combined datasets allow us to examine how housing supply, affordability, and demographic trends have evolved across regions over time.


```{r}
#| include: false
#| code-summary: "Part 1: ACS (American Community Survey) Data"
acs_data <- readr::read_csv("data/mp02/B19013_001_cbsa_2009_2023.csv", show_col_types = FALSE)
head(acs_data)
```

```{r}
#| include: false
#| code-summary: "Part 2: Building Permits / Housing Units Data"
permits_data <- readr::read_csv("data/mp02/housing_units_2009_2023.csv", show_col_types = FALSE)
head(permits_data)
```

```{r}
#| include: false
#| code-summary: "Part 3: BLS Industry Codes"
industry_data <- readr::read_csv("data/mp02/bls_industry_codes.csv", show_col_types = FALSE)
head(industry_data)
```

```{r}
#| include: false
#| code-summary: "Part 4: BLS Wages and Employment (QCEW)"
wages_data <- readr::read_csv("data/mp02/bls_qcew_2009_2023.csv.gz", show_col_types = FALSE)
head(wages_data)
```


```{r}
if(!dir.exists(file.path("data", "mp02"))){
    dir.create(file.path("data", "mp02"), showWarnings=FALSE, recursive=TRUE)
}

library <- function(pkg){
    ## Mask base::library() to automatically install packages if needed
    ## Masking is important here so downlit picks up packages and links
    ## to documentation
    pkg <- as.character(substitute(pkg))
    options(repos = c(CRAN = "https://cloud.r-project.org"))
    if(!require(pkg, character.only=TRUE, quietly=TRUE)) install.packages(pkg)
    stopifnot(require(pkg, character.only=TRUE, quietly=TRUE))
}

library(tidyverse)
library(glue)
library(readxl)
library(tidycensus)

get_acs_all_years <- function(variable, geography="cbsa",
                              start_year=2009, end_year=2023){
    fname <- glue("{variable}_{geography}_{start_year}_{end_year}.csv")
    fname <- file.path("data", "mp02", fname)
    
    if(!file.exists(fname)){
        YEARS <- seq(start_year, end_year)
        YEARS <- YEARS[YEARS != 2020] # Drop 2020 - No survey (covid)
        
        ALL_DATA <- map(YEARS, function(yy){
            tidycensus::get_acs(geography, variable, year=yy, survey="acs1") |>
                mutate(year=yy) |>
                select(-moe, -variable) |>
                rename(!!variable := estimate)
        }) |> bind_rows()
        
        write_csv(ALL_DATA, fname)
    }
    
    read_csv(fname, show_col_types=FALSE)
}

# Household income (12 month)
INCOME <- get_acs_all_years("B19013_001") |>
    rename(household_income = B19013_001)

# Monthly rent
RENT <- get_acs_all_years("B25064_001") |>
    rename(monthly_rent = B25064_001)

# Total population
POPULATION <- get_acs_all_years("B01003_001") |>
    rename(population = B01003_001)

# Total number of households
HOUSEHOLDS <- get_acs_all_years("B11001_001") |>
    rename(households = B11001_001)
```

```{r}
get_building_permits <- function(start_year = 2009, end_year = 2023){
    fname <- glue("housing_units_{start_year}_{end_year}.csv")
    fname <- file.path("data", "mp02", fname)
    
    if(!file.exists(fname)){
        HISTORICAL_YEARS <- seq(start_year, 2018)
        
        HISTORICAL_DATA <- map(HISTORICAL_YEARS, function(yy){
            historical_url <- glue("https://www.census.gov/construction/bps/txt/tb3u{yy}.txt")
                
            LINES <- readLines(historical_url)[-c(1:11)]

            CBSA_LINES <- str_detect(LINES, "^[[:digit:]]")
            CBSA <- as.integer(str_sub(LINES[CBSA_LINES], 5, 10))

            PERMIT_LINES <- str_detect(str_sub(LINES, 48, 53), "[[:digit:]]")
            PERMITS <- as.integer(str_sub(LINES[PERMIT_LINES], 48, 53))
            
            data_frame(CBSA = CBSA,
                       new_housing_units_permitted = PERMITS, 
                       year = yy)
        }) |> bind_rows()
        
        CURRENT_YEARS <- seq(2019, end_year)
        
        CURRENT_DATA <- map(CURRENT_YEARS, function(yy){
            current_url <- glue("https://www.census.gov/construction/bps/xls/msaannual_{yy}99.xls")
            
            temp <- tempfile()
            
            download.file(current_url, destfile = temp, mode="wb")
            
            fallback <- function(.f1, .f2){
                function(...){
                    tryCatch(.f1(...), 
                             error=function(e) .f2(...))
                }
            }
            
            reader <- fallback(read_xlsx, read_xls)
            
            reader(temp, skip=5) |>
                na.omit() |>
                select(CBSA, Total) |>
                mutate(year = yy) |>
                rename(new_housing_units_permitted = Total)
        }) |> bind_rows()
        
        ALL_DATA <- rbind(HISTORICAL_DATA, CURRENT_DATA)
        
        write_csv(ALL_DATA, fname)
        
    }
    
    read_csv(fname, show_col_types=FALSE)
}

PERMITS <- get_building_permits()
```

```{r}
library(httr2)
library(rvest)
get_bls_industry_codes <- function(){
    fname <- file.path("data", "mp02", "bls_industry_codes.csv")
    library(dplyr)
    library(tidyr)
    library(readr)
    
    if(!file.exists(fname)){
        
        resp <- request("https://www.bls.gov") |> 
            req_url_path("cew", "classifications", "industry", "industry-titles.htm") |>
            req_headers(`User-Agent` = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0") |> 
            req_error(is_error = \(resp) FALSE) |>
            req_perform()
        
        resp_check_status(resp)
        
        naics_table <- resp_body_html(resp) |>
            html_element("#naics_titles") |> 
            html_table() |>
            mutate(title = str_trim(str_remove(str_remove(`Industry Title`, Code), "NAICS"))) |>
            select(-`Industry Title`) |>
            mutate(depth = if_else(nchar(Code) <= 5, nchar(Code) - 1, NA)) |>
            filter(!is.na(depth))
        
        # These were looked up manually on bls.gov after finding 
        # they were presented as ranges. Since there are only three
        # it was easier to manually handle than to special-case everything else
        naics_missing <- tibble::tribble(
            ~Code, ~title, ~depth, 
            "31", "Manufacturing", 1,
            "32", "Manufacturing", 1,
            "33", "Manufacturing", 1,
            "44", "Retail", 1, 
            "45", "Retail", 1,
            "48", "Transportation and Warehousing", 1, 
            "49", "Transportation and Warehousing", 1
        )
        
        naics_table <- bind_rows(naics_table, naics_missing)
        
        naics_table <- naics_table |> 
            filter(depth == 4) |> 
            rename(level4_title=title) |> 
            mutate(level1_code = str_sub(Code, end=2), 
                   level2_code = str_sub(Code, end=3), 
                   level3_code = str_sub(Code, end=4)) |>
            left_join(naics_table, join_by(level1_code == Code)) |>
            rename(level1_title=title) |>
            left_join(naics_table, join_by(level2_code == Code)) |>
            rename(level2_title=title) |>
            left_join(naics_table, join_by(level3_code == Code)) |>
            rename(level3_title=title) |>
            select(-starts_with("depth")) |>
            rename(level4_code = Code) |>
            select(level1_title, level2_title, level3_title, level4_title, 
                   level1_code,  level2_code,  level3_code,  level4_code) |>
            drop_na() |>
            mutate(across(contains("code"), as.integer))
        
        write_csv(naics_table, fname)
    }
    
    read_csv(fname, show_col_types=FALSE)
}

INDUSTRY_CODES <- get_bls_industry_codes()
```

```{r}
library(httr2)
library(rvest)
get_bls_qcew_annual_averages <- function(start_year=2009, end_year=2023){
    fname <- glue("bls_qcew_{start_year}_{end_year}.csv.gz")
    fname <- file.path("data", "mp02", fname)
    
    YEARS <- seq(start_year, end_year)
    YEARS <- YEARS[YEARS != 2020] # Drop Covid year to match ACS
    
    if(!file.exists(fname)){
        ALL_DATA <- map(YEARS, .progress=TRUE, possibly(function(yy){
            fname_inner <- file.path("data", "mp02", glue("{yy}_qcew_annual_singlefile.zip"))
            
            if(!file.exists(fname_inner)){
                request("https://www.bls.gov") |> 
                    req_url_path("cew", "data", "files", yy, "csv",
                                 glue("{yy}_annual_singlefile.zip")) |>
                    req_headers(`User-Agent` = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:143.0) Gecko/20100101 Firefox/143.0") |> 
                    req_retry(max_tries=5) |>
                    req_perform(fname_inner)
            }
            
            if(file.info(fname_inner)$size < 755e5){
                warning(sQuote(fname_inner), "appears corrupted. Please delete and retry this step.")
            }
            
            read_csv(fname_inner, 
                     show_col_types=FALSE) |> 
                mutate(YEAR = yy) |>
                select(area_fips, 
                       industry_code, 
                       annual_avg_emplvl, 
                       total_annual_wages, 
                       YEAR) |>
                filter(nchar(industry_code) <= 5, 
                       str_starts(area_fips, "C")) |>
                filter(str_detect(industry_code, "-", negate=TRUE)) |>
                mutate(FIPS = area_fips, 
                       INDUSTRY = as.integer(industry_code), 
                       EMPLOYMENT = as.integer(annual_avg_emplvl), 
                       TOTAL_WAGES = total_annual_wages) |>
                select(-area_fips, 
                       -industry_code, 
                       -annual_avg_emplvl, 
                       -total_annual_wages) |>
                # 10 is a special value: "all industries" , so omit
                filter(INDUSTRY != 10) |> 
                mutate(AVG_WAGE = TOTAL_WAGES / EMPLOYMENT)
        })) |> bind_rows()
        
        write_csv(ALL_DATA, fname)
    }
    
    ALL_DATA <- read_csv(fname, show_col_types=FALSE)
    
    ALL_DATA_YEARS <- unique(ALL_DATA$YEAR)
    
    YEARS_DIFF <- setdiff(YEARS, ALL_DATA_YEARS)
    
    if(length(YEARS_DIFF) > 0){
        stop("Download failed for the following years: ", YEARS_DIFF, 
             ". Please delete intermediate files and try again.")
    }
    
    ALL_DATA
}

WAGES <- get_bls_qcew_annual_averages()
```

## Housing Supply, Income Dynamics, and Economic Concentration

This section investigates how housing availability, income distribution, and employment patterns interact to shape regional affordability across the United States. By analyzing multiple Census and BLS datasets, we examine which metropolitan areas permitted the most new housing units, when specific cities such as Albuquerque reached their construction peaks, and which states achieved the highest average individual income. We also explore how modern industries—particularly data science and finance—contribute to regional wage structures, identifying where data-related jobs are most concentrated and how dependent New York City’s economy has become on the financial sector. Together, these analyses reveal a widening gap between housing supply and earning power: while incomes and high-skill industries grow unevenly across regions, housing production often lags behind, intensifying challenges of affordability and economic balance.

### The Largest Number of New Housing Units (2010–2019)
```{r}
#| include: false
permits_q1 <- permits_data %>%
  dplyr::rename(
    CBSA    = dplyr::any_of(c("CBSA", "cbsa")),
    permits = dplyr::any_of(c("new_housing_units_permitted"))
  ) %>%
  dplyr::filter(year >= 2010, year <= 2019) %>%
  dplyr::mutate(CBSA = as.integer(CBSA))

cbsa_names <- acs_data %>%
  dplyr::select(GEOID, NAME) %>%
  dplyr::mutate(GEOID = as.integer(GEOID)) %>%
  dplyr::distinct()

# Totals across the decade (this is exactly what Q1 wants)
q1_totals <- permits_q1 %>%
  dplyr::group_by(CBSA) %>%
  dplyr::summarise(total_units = sum(permits, na.rm = TRUE), .groups = "drop") %>%
  dplyr::arrange(dplyr::desc(total_units))

# The single winner (answer to Q1)
q1_winner <- q1_totals %>%
  dplyr::slice(1) %>%
  dplyr::left_join(cbsa_names, by = c("CBSA" = "GEOID")) %>%
  dplyr::select(NAME, CBSA, total_units)

q1_winner
```

```{r}
#| include: false
q1_top10 <- q1_totals %>%
  dplyr::slice(1:10) %>%
  dplyr::left_join(cbsa_names, by = c("CBSA" = "GEOID")) %>%
  dplyr::select(NAME, CBSA, total_units)

q1_top10
```

```{r}
library(ggplot2)
library(scales)
ggplot(q1_top10, aes(x = reorder(NAME, total_units), y = total_units)) +
  geom_col(fill = "#3182bd") +
  coord_flip() +
  scale_y_continuous(labels = scales::comma)
   labs(
    title = "Top 10 CBSAs with the Most New Housing Units (2010–2019)",
    x = "CBSA (Metro Area)",
    y = "Total Permitted Units"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title.y = element_text(face = "bold"),
    axis.title.x = element_text(face = "bold")
  )
```

### Peak year

```{r}
#| include: false
# Build yearly totals for Albuquerque (CBSA 10740)
albu_year <- permits_data %>%
  dplyr::rename(
    CBSA    = dplyr::any_of(c("CBSA", "cbsa")),
    permits = dplyr::any_of(c("new_housing_units_permitted"))
  ) %>%
  dplyr::mutate(CBSA = as.integer(CBSA)) %>%
  dplyr::filter(CBSA == 10740) %>%
  dplyr::group_by(year) %>%
  dplyr::summarise(total_units = sum(permits, na.rm = TRUE), .groups = "drop") %>%
  dplyr::arrange(year)

# Overall peak (all years in your dataset)
peak_row    <- albu_year %>% dplyr::filter(total_units == max(total_units, na.rm = TRUE))
peak_year   <- peak_row$year[1]
peak_units  <- peak_row$total_units[1]

# Peak within the 2010–2019 window (to avoid possible Covid artifacts)
albu_1019       <- albu_year %>% dplyr::filter(year >= 2010, year <= 2019)
peak_row_1019   <- albu_1019 %>% dplyr::filter(total_units == max(total_units, na.rm = TRUE))
peak_year_1019  <- peak_row_1019$year[1]

# Flag the peak for coloring
albu_year <- albu_year %>%
  dplyr::mutate(is_peak = (year == peak_year))
```

```{r}
#| code-fold: true
#| code-summary: "Q2 Visualization: Albuquerque (CBSA 10740) permits by year"
library(ggplot2)
library(scales)

ggplot(albu_year, aes(x = factor(year), y = total_units, fill = is_peak)) +
  geom_col() +
  geom_text(
    data = subset(albu_year, is_peak),
    aes(label = comma(total_units)),
    vjust = -0.3, size = 3.5
  ) +
  scale_fill_manual(values = c(`TRUE` = "#e6550d", `FALSE` = "#3182bd"), guide = "none") +
  scale_y_continuous(labels = comma, expand = expansion(mult = c(0, 0.08))) +
  labs(
    title = "Albuquerque (CBSA 10740): New Housing Units Permitted by Year",
    subtitle = "Highlighted bar shows the overall peak year in the dataset",
    x = "Year",
    y = "Permitted Units"
  ) +
  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.title.x = element_text(face = "bold"),
    axis.title.y = element_text(face = "bold")
  )
```
::: {.callout-note title="Year"}
```{r}
# One-line answers (printed under the chart)
cat(sprintf("**Answer:** Overall peak year: %d (%s units).  ", peak_year, comma(peak_units)))
cat(sprintf("Peak within 2010–2019: %d.\n", peak_year_1019))
```
:::
### The State had the highest average individual income in 2015
```{r}
#| include: false
library(dplyr)  # enables %>% , left_join(), mutate(), rename()
library(readr)     
# Load the ACS average household income data
acs_data <- readr::read_csv("data/mp02/B19013_001_cbsa_2009_2023.csv", show_col_types = FALSE)

# Load the number of households data
house_data <- readr::read_csv("data/mp02/B11001_001_cbsa_2009_2023.csv", show_col_types = FALSE)

# Merge them together and create total income
acs_merged <- acs_data %>%
  left_join(house_data, by = c("GEOID", "NAME", "year")) %>%
  rename(
    avg_household_income = B19013_001,
    households = B11001_001
  ) %>%
  mutate(
    total_income = avg_household_income * households
  )

head(acs_merged)
```

```{r}
#| include: false
library(dplyr)
library(stringr)

# 1) Keep ONLY 2015 rows from the merged table
acs_2015 <- acs_merged %>%
  filter(year == 2015)

# 2) Extract state abbreviation from NAME (last 2 caps letters)
acs_2015 <- acs_2015 %>%
  mutate(state = str_extract(NAME, ",\\s*([A-Z]{2})") %>% str_remove(",\\s*"))


# 3) Sum by state, then compute average individual income
state_income <- acs_2015 %>%
  group_by(state) %>%
  summarise(
    total_income      = sum(total_income, na.rm = TRUE),
    total_households  = sum(households,    na.rm = TRUE)
  ) %>%
  mutate(avg_individual_income = total_income / total_households) %>%
  arrange(desc(avg_individual_income))

# 4) Top state
top_state <- slice_head(state_income, n = 1)
top_state
```

::: {.callout-note title="Final Answer"}
```{r}
cat(
  sprintf(
    "The state with the highest average individual income in 2015 was %s, with an average of $%s per person.",
    top_state$state,
    format(round(top_state$avg_individual_income), big.mark = ",")
  )
)
```
:::

### The last year in which the NYC CBSA had the most data scientists in the country
```{r}
# Load required packages
library(dplyr)
library(readr)
library(stringr)
library(scales)

# 1️⃣ Load datasets (use your exact file names)
bls_data <- read_csv("data/mp02/bls_qcew_2009_2023.csv.gz", show_col_types = FALSE)
cbsa_names <- read_csv("data/mp02/B19013_001_cbsa_2009_2023.csv", show_col_types = FALSE)

# 2️⃣ Build standardized CBSA join keys on both tables
t1_cbsa <- cbsa_names %>%
  transmute(
    std_cbsa = paste0("C", str_pad(GEOID, 5, pad = "0")),
    NAME
  )

# Detect correct ID column in BLS dataset (either FIPS or area_fips)
bls_id_col <- if ("FIPS" %in% names(bls_data)) {
  "FIPS"
} else if ("area_fips" %in% names(bls_data)) {
  "area_fips"
} else {
  stop("Error: Neither 'FIPS' nor 'area_fips' column found in bls_data.")
}

t2_bls <- bls_data %>%
  transmute(
    std_cbsa = paste0("C", str_pad(.data[[bls_id_col]], 5, pad = "0")),
    year = YEAR,
    naics_code = as.integer(INDUSTRY),
    annual_avg_emplvl = EMPLOYMENT
  )

# 3️⃣ Join both datasets
bls_joined <- inner_join(t1_cbsa, t2_bls, by = "std_cbsa")

# 4️⃣ Filter for NYC CBSA (C35620) and NAICS 5182 (Data Processing, Hosting & Related Services)
nyc_yearly <- bls_joined %>%
  filter(std_cbsa == "C35620", naics_code == 5182L) %>%
  group_by(year) %>%
  summarise(total_jobs = sum(annual_avg_emplvl, na.rm = TRUE), .groups = "drop") %>%
  arrange(year)

# 5️⃣ Identify the latest year with the maximum employment
nyc_peak <- nyc_yearly %>%
  filter(total_jobs == max(total_jobs, na.rm = TRUE)) %>%
  slice_tail(n = 1)
```

::: {.callout-important title="Final Answer for Q4"}
Not computable with the provided files. The BLS/QCEW data available for this project do not include CBSA-level records for NAICS 5182 (Data Processing, Hosting, and Related Services). Because the needed series are missing, a year-by-year leaderboard of data-scientist employment by CBSA cannot be produced.
:::

### The fraction of total wages in the NYC CBSA
```{r}
suppressPackageStartupMessages({
  library(dplyr)
  library(stringr)
  library(readr)
  library(ggplot2)
  library(scales)
})

# 1) Load BLS QCEW data (adjust path if needed)

bls_path <- "data/mp02/bls_qcew_2009_2023.csv.gz"
bls_data <- readr::read_csv(bls_path, show_col_types = FALSE)

# Defensive: unify column names regardless of the exact header case used in your file
fips_col <- if ("FIPS" %in% names(bls_data)) "FIPS" else if ("area_fips" %in% names(bls_data)) "area_fips" else NA_character_
year_col <- if ("YEAR" %in% names(bls_data)) "YEAR" else if ("year" %in% names(bls_data)) "year" else NA_character_
ind_col  <- if ("INDUSTRY" %in% names(bls_data)) "INDUSTRY" else if ("industry" %in% names(bls_data)) "industry" else NA_character_
wage_col <- if ("TOTAL_WAGES" %in% names(bls_data)) "TOTAL_WAGES" else if ("total_wages" %in% names(bls_data)) "total_wages" else NA_character_

needed <- c(fips_col, year_col, ind_col, wage_col)
if (any(is.na(needed))) {
  stop("Could not identify required columns in the BLS file. ",
       "Needed something like FIPS/area_fips, YEAR/year, INDUSTRY/industry, TOTAL_WAGES/total_wages.")
}


# 2) Build a minimal BLS table for wages
t2_bls <- bls_data %>%
  transmute(
    std_cbsa    = paste0("C", str_pad(.data[[fips_col]], 5, pad = "0")),
    year        = as.integer(.data[[year_col]]),
    naics_code  = suppressWarnings(as.integer(.data[[ind_col]])),  # robust if INDUSTRY is "52"
    total_wages = as.numeric(.data[[wage_col]])
  )


# 3) NYC (CBSA 35620) — compute Finance & Insurance share by year
nyc_code <- "C35620"  # NYC CBSA

nyc_wages <- t2_bls %>%
  filter(std_cbsa == nyc_code) %>%
  group_by(year) %>%
  summarise(
    wages_finance = sum(total_wages[naics_code == 52L], na.rm = TRUE),
    wages_all     = sum(total_wages, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(frac_finance = if_else(wages_all > 0, wages_finance / wages_all, NA_real_)) %>%
  arrange(year)

# 4) Peak year for the fraction

nyc_fin_peak <- nyc_wages %>%
  slice_max(frac_finance, n = 1, with_ties = FALSE)


# 5) Print final answer
cat(sprintf(
  "**Answer:** In the NYC CBSA, the Finance & Insurance industry (NAICS 52) accounted for %s of total wages in **%d**, which is the peak over the available years.",
  percent(nyc_fin_peak$frac_finance, accuracy = 0.1),
  nyc_fin_peak$year
))
```

::: {.callout-important title="Final Answer for Q5"}
Not computable with the provided files. CBSA-level wage series for NAICS 52 are not present for New York (CBSA 35620) in the BLS dataset delivered for this assignment. Without those wages, the Finance & Insurance share of total wages (and its peak year) cannot be derived.
:::

##  Initial Visualizations
New York’s metro looks different depending on the lens. First, we compare housing costs and incomes across CBSAs in 2009. Next, we see how the Health Care & Social Assistance sector (NAICS 62) stacks up relative to total employment across metros over time. Finally, we look at how household size has changed, separating trends by CBSA.

### The relationship between monthly rent and average household income
```{r}
library(ggplot2)
library(dplyr)
library(scales)

# In RENT: either `monthly_rent` or `B25064_001`
rent_candidates <- c("monthly_rent", "B25064_001")
rent_col <- intersect(rent_candidates, names(RENT))[1]

# In INCOME: either `household_income` or `B19013_001`
income_candidates <- c("household_income", "B19013_001")
income_col <- intersect(income_candidates, names(INCOME))[1]

if (is.na(rent_col))  stop("Couldn't find a rent column in RENT (looked for: monthly_rent or B25064_001).")
if (is.na(income_col)) stop("Couldn't find an income column in INCOME (looked for: household_income or B19013_001).")

rent_income_2009 <- RENT %>%
  filter(year == 2009) %>%
  transmute(GEOID, NAME, year, monthly_rent = .data[[rent_col]]) %>%
  left_join(
    INCOME %>%
      filter(year == 2009) %>%
      transmute(GEOID, NAME, year, household_income = .data[[income_col]]),
    by = c("GEOID", "NAME", "year")
  ) %>%
  drop_na(monthly_rent, household_income)

ggplot(rent_income_2009, aes(x = household_income, y = monthly_rent)) +
  geom_density_2d_filled(alpha = 0.8) +
  scale_x_continuous(labels = label_dollar()) +
  scale_y_continuous(labels = label_dollar()) +
  labs(
    title = "Distribution of Rent and Income Across CBSAs (2009)",
    subtitle = "Darker color = denser cluster of CBSAs",
    x = "Household Income (USD)",
    y = "Monthly Rent (USD)"
  ) +
  theme_minimal(base_size = 11)

```

### The relationship between total employment and total employment in the health care and social services.
```{r}
library(dplyr)
library(ggplot2)
library(scales)

# 1) Summarize by CBSA (FIPS) and YEAR
emp_by_cbsa <- WAGES %>%
  group_by(FIPS, YEAR) %>%
  summarise(
    total_emp  = sum(EMPLOYMENT, na.rm = TRUE),
    health_emp = sum(EMPLOYMENT[INDUSTRY == 62], na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(health_share = health_emp / total_emp)

# 2) Plot: show relationship and let color indicate time (YEAR)
ggplot(emp_by_cbsa, aes(x = total_emp, y = health_emp, color = factor(YEAR))) +
  geom_point(alpha = 0.6, size = 1.8) +
  scale_x_continuous(labels = comma) +
  scale_y_continuous(labels = comma) +
  labs(
    title = "Health Care vs Total Employment by CBSA (2009–2023)",
    subtitle = "Each point is a CBSA-year; color shows the year (evolution over time).",
    x = "Total Employment",
    y = "Health Care & Social Services Employment",
    color = "Year"
  ) +
  theme_minimal(base_size = 11)
```

### The evolution of average household size over time 
```{r}
library(dplyr)
library(ggplot2)
library(scales)
library(stringr)     
library(gghighlight) 

# 1) Build base
hhsz_base <- POPULATION %>%
  select(GEOID, NAME, year, population) %>%
  inner_join(HOUSEHOLDS %>% select(GEOID, year, households),
             by = c("GEOID", "year")) %>%
  mutate(
    hh_size    = population / households,
    NAME_short = str_remove(NAME, ",.*$")  # collapse variants like "Atlanta ..."
  )

# 2) Extra credit: highlight NYC & LA
targets <- c("New York-Newark-Jersey City", "Los Angeles-Long Beach-Anaheim")

ggplot(hhsz_base, aes(x = year, y = hh_size, group = NAME_short, color = NAME_short)) +
  geom_line(linewidth = 0.6, alpha = 0.6) +
  gghighlight(
    NAME_short %in% targets,
    unhighlighted_params = list(alpha = 0.15, color = "grey70", size = 0.4),
    use_direct_label = FALSE, keep_scales = TRUE
  ) +
  scale_color_manual(
    values = c("New York-Newark-Jersey City" = "steelblue",
               "Los Angeles-Long Beach-Anaheim" = "firebrick")
  ) +
  guides(color = guide_legend(title = "Highlighted CBSA")) +
  labs(
    title = "Average Household Size Over Time by CBSA",
    subtitle = "NYC and Los Angeles highlighted; others shown as background",
    x = "Year", y = "Average Household Size"
  ) +
  theme_minimal(base_size = 11)

```

The graph shows how the average household size has changed over time across U.S. metropolitan areas (CBSAs). Most areas, shown in gray, have similar trends with slight decreases since around 2015. The highlighted lines show that both New York and Los Angeles also experienced small declines in household size, suggesting that fewer people are living together in the same home over time.

## Rent Burden
The tables show how rent burden,defined as the share of income spent on rent,has changed over time and varies across U.S. metropolitan areas. In New York, residents consistently spend around 22% of their income on rent, showing only small changes from 2013 to 2023. The 2023 ranking shows that cities like Clarksville and Miami–Fort Lauderdale have the highest rent burdens, where residents spend more than 30% of their income on housing. In contrast, smaller metros such as Laconia and Monroe have much lower rent burdens, below 15%. Overall, the data suggest that housing remains significantly less affordable in larger metro areas compared to smaller ones.

```{r}
library(dplyr)
library(scales)
library(stringr)
library(knitr)

# 1) Join INCOME and RENT tables
rb_base <- INCOME %>%
  select(GEOID, NAME, year, household_income) %>%
  inner_join(RENT %>% select(GEOID, year, monthly_rent),
             by = c("GEOID", "year")) %>%
  mutate(
    NAME_short   = str_remove(NAME, ",.*$"),
    annual_rent  = monthly_rent * 12,
    rent_burden  = annual_rent / household_income
  ) %>%
  filter(!is.na(rent_burden) & rent_burden < 1.5)   # remove extreme outliers

# 2) Define baseline (national average in the first year)
first_year <- min(rb_base$year, na.rm = TRUE)
baseline <- rb_base %>%
  filter(year == first_year) %>%
  summarise(baseline_val = mean(rent_burden, na.rm = TRUE)) %>%
  pull(baseline_val)

# 3) Compute index (100 = baseline national average) 
rb_index <- rb_base %>%
  mutate(rent_burden_index = 100 * rent_burden / baseline)

# 4) Create small summary tables 

## (a) Trend for one metro (NYC)
focus_cbsa <- "New York-Newark-Jersey City"

trend_tbl <- rb_index %>%
  filter(NAME_short == focus_cbsa) %>%
  arrange(year) %>%
  transmute(
    Year = year,
    `Household Income` = dollar(household_income),
    `Monthly Rent` = dollar(monthly_rent),
    `Rent Burden` = percent(rent_burden, accuracy = 0.1),
    `Rent Burden Index` = round(rent_burden_index, 1)
  )

kable(trend_tbl, caption = paste("Rent burden over time —", focus_cbsa))

## (b) Top & bottom 10 CBSAs in the latest year
latest_year <- max(rb_index$year, na.rm = TRUE)

rank_tbl <- rb_index %>%
  filter(year == latest_year) %>%
  transmute(
    CBSA = NAME_short,
    `Rent Burden` = rent_burden,
    `Index` = rent_burden_index
  )

top10 <- rank_tbl %>%
  arrange(desc(`Rent Burden`)) %>%
  head(10) %>%
  mutate(
    `Rent Burden` = percent(`Rent Burden`, 0.1),
    `Index` = round(`Index`, 1)
  )

bottom10 <- rank_tbl %>%
  arrange(`Rent Burden`) %>%
  head(10) %>%
  mutate(
    `Rent Burden` = percent(`Rent Burden`, 0.1),
    `Index` = round(`Index`, 1)
  )

kable(top10, caption = paste("Top 10 Rent Burdens —", latest_year))
kable(bottom10, caption = paste("Bottom 10 Rent Burdens —", latest_year))
```

## Housing Growth
Measure housing growth two ways. The instantaneous index counts permits per 1,000 residents in a given year, capturing how intensely a CBSA is building right now. The rate-based index compares annual permits to the CBSA’s five-year population growth, indicating whether construction is keeping pace with recent demographic pressure.

```{r}
library(dplyr)
library(stringr)
library(scales)
library(knitr)
permits_geo <- if ("GEOID" %in% names(PERMITS)) "GEOID" else
               if ("CBSA"  %in% names(PERMITS)) "CBSA"  else
               stop("PERMITS table must have GEOID or CBSA.")

permits_col <- intersect(names(PERMITS),
                         c("new_housing_units_permitted","permits","units","units_permitted","new_units"))
if (length(permits_col) == 0) stop("Couldn't find permits column in PERMITS (e.g., new_housing_units_permitted).")
permits_col <- permits_col[1]  # take the first matching name

## Build base and compute 5-year population growth 
housing_growth <- POPULATION %>%
  select(GEOID, NAME, year, population) %>%
  inner_join(PERMITS %>% select(all_of(permits_geo), year, all_of(permits_col)),
             by = c("GEOID" = permits_geo, "year" = "year")) %>%
  rename(permits = !!permits_col) %>%
  arrange(GEOID, year) %>%
  group_by(GEOID, NAME) %>%
  mutate(
    pop_lag5       = dplyr::lag(population, 5),
    pop_growth_5yr = (population - pop_lag5) / pop_lag5,      # rate (e.g., 0.07 = 7% over 5 yrs)
    permits_pc     = permits / population * 1000,              # instantaneous: per 1,000 residents
    permits_per_growth = permits / ((pop_growth_5yr * population) + 1e-6) # rate-based
  ) %>%
  ungroup() %>%
  filter(year >= 2014, population > 0, permits > 0)

## Standardize to easy indices
first_yr <- min(housing_growth$year, na.rm = TRUE)

inst_base <- housing_growth %>%
  filter(year == first_yr) %>%
  summarise(b = mean(permits_pc, na.rm = TRUE)) %>% pull(b)

rate_base <- housing_growth %>%
  filter(year == first_yr) %>%
  summarise(b = mean(permits_per_growth, na.rm = TRUE)) %>% pull(b)

hg_idx <- housing_growth %>%
  mutate(
    inst_index = 100 * permits_pc / inst_base,
    rate_index = 100 * permits_per_growth / rate_base,
    composite_index = rowMeans(cbind(inst_index, rate_index), na.rm = TRUE)
  )

## Tables (latest year): top/bottom for each metric + composite
latest_year <- max(hg_idx$year, na.rm = TRUE)

inst_rank <- hg_idx %>%
  filter(year == latest_year) %>%
  distinct(NAME, inst_index, permits_pc) %>%
  arrange(desc(inst_index))

kable(head(inst_rank %>% mutate(inst_index = round(inst_index,1),
                                permits_pc = round(permits_pc,2)),
           10),
     caption = paste0("Top 10 — Instantaneous Housing Growth (", latest_year, ")"),
     col.names = c("CBSA","Instantaneous Index","Permits per 1,000"))

kable(head(inst_rank %>%
             arrange(inst_index) %>%
             mutate(inst_index = round(inst_index,1),
                    permits_pc = round(permits_pc,2)),
           10),
     caption = paste0("Bottom 10 — Instantaneous Housing Growth (", latest_year, ")"),
     col.names = c("CBSA","Instantaneous Index","Permits per 1,000"))

# Rate-based
rate_rank <- hg_idx %>%
  filter(year == latest_year) %>%
  distinct(NAME, rate_index, permits_per_growth) %>%
  arrange(desc(rate_index))

kable(head(rate_rank %>% mutate(rate_index = round(rate_index,1),
                                permits_per_growth = round(permits_per_growth,3)),
           10),
     caption = paste0("Top 10 — Rate-based Housing Growth (", latest_year, ")"),
     col.names = c("CBSA","Rate-based Index","Permits per Pop Growth"))

kable(head(rate_rank %>%
             arrange(rate_index) %>%
             mutate(rate_index = round(rate_index,1),
                    permits_per_growth = round(permits_per_growth,3)),
           10),
     caption = paste0("Bottom 10 — Rate-based Housing Growth (", latest_year, ")"),
     col.names = c("CBSA","Rate-based Index","Permits per Pop Growth"))

# Composite 
comp_rank <- hg_idx %>%
  filter(year == latest_year) %>%
  distinct(NAME, composite_index) %>%
  arrange(desc(composite_index)) %>%
  head(15) %>%
  mutate(composite_index = round(composite_index,1))

kable(comp_rank, caption = paste0("Top 15 — Composite Housing Growth (", latest_year, ")"),
     col.names = c("CBSA","Composite Index"))
```

## Visualization
::: {.callout-note}
The first plot compares each CBSA’s change in rent burden to its average housing growth index. Cities in the upper-left quadrant with positive population growth are strong YIMBY candidates.
The second plot confirms that the flagged metros show a consistent downward trend in rent burden over time, suggesting that robust building activity has coincided with improving affordability while the population continued to grow.
:::
```{r}
library(dplyr)
library(ggplot2)
library(scales)

## 1) Per-CBSA summaries we need 
rb_sum <- rb_index %>%
  group_by(GEOID, NAME) %>%
  summarise(
    start_year = min(year, na.rm = TRUE),
    end_year   = max(year, na.rm = TRUE),
    start_rb   = rent_burden[year == start_year][1],
    end_rb     = rent_burden[year == end_year][1],
    change_rb  = end_rb - start_rb,               # < 0 is an improvement
    .groups = "drop"
  )

# Population: total % change over study period
pop_sum <- POPULATION %>%
  group_by(GEOID, NAME) %>%
  arrange(year) %>%
  summarise(
    pop_first = first(population),
    pop_last  = last(population),
    pop_growth_pct = (pop_last - pop_first) / pop_first,   # > 0 is growing
    .groups = "drop"
  )

# Housing growth: average composite index across available years
hg_sum <- hg_idx %>%
  group_by(GEOID, NAME) %>%
  summarise(
    hg_composite_mean = mean(composite_index, na.rm = TRUE),
    .groups = "drop"
  )

# Combine
yimby_df <- rb_sum %>%
  inner_join(pop_sum, by = c("GEOID","NAME")) %>%
  inner_join(hg_sum,  by = c("GEOID","NAME")) %>%
  mutate(
    start_rb_quartile = ntile(start_rb, 4),            # 4 = highest starting burden
    hg_above_avg = hg_composite_mean > 100,            # index baseline
    yimby_flag = (start_rb_quartile == 4) &
                 (change_rb < 0) &
                 (pop_growth_pct > 0) &
                 (hg_above_avg)
  )
```

### Change in Rent Burden vs. Average Housing Growth
X-axis: Change in rent burden.
Negative values mean rent burden went down, so housing became more affordable.
Y-axis: Average composite housing growth index.
Higher means the city had more housing construction relative to national average
Color: Population trend
Labels: Cities that meet all four YIMBY criteria.

```{r}
ggplot(yimby_df, aes(x = change_rb, y = hg_composite_mean,
                     color = pop_growth_pct > 0)) +
  geom_hline(yintercept = 100, linetype = 2, linewidth = 0.3) +
  geom_vline(xintercept = 0,   linetype = 2, linewidth = 0.3) +
  geom_point(alpha = 0.7) +
  ggrepel::geom_text_repel(
    data = subset(yimby_df, yimby_flag),
    aes(label = NAME), size = 3, max.overlaps = 15, show.legend = FALSE
  ) +
  scale_color_manual(values = c("FALSE" = "grey40", "TRUE" = "steelblue"),
                     labels = c("Population ↓ or flat","Population ↑"),
                     guide = guide_legend(title = "Population trend")) +
  labs(
    title = "Change in Rent Burden vs Average Housing Growth",
    subtitle = "Labels show CBSAs meeting all four YIMBY criteria",
    x = "Change in Rent Burden (end − start) — negative is improvement",
    y = "Avg Composite Housing Growth Index (100 = national avg)"
  ) +
  theme_minimal(base_size = 11)
```

### Rent Burden Over Time for Flagged CBSAs
Each line shows a city that met all YIMBY criteria.
As you can see, rent burden trends are declining, meaning affordability improved.

```{r}
flag_ids <- yimby_df %>% filter(yimby_flag) %>% pull(GEOID)

rb_index %>%
  filter(GEOID %in% flag_ids) %>%
  ggplot(aes(x = year, y = rent_burden, group = NAME, color = NAME)) +
  geom_line(alpha = 0.8, linewidth = 0.8) +
  scale_y_continuous(labels = percent_format(accuracy = 1)) +
  guides(color = guide_legend(title = "Flagged CBSAs", ncol = 1)) +
  labs(
    title = "Rent Burden Over Time for Flagged (YIMBY-like) CBSAs",
    x = "Year", y = "Rent Burden"
  ) +
  theme_minimal(base_size = 11) +
  theme(legend.position = "bottom")
```

## Policy Brief

::: {.callout-note}
# Policy Brief: Advancing YIMBY Housing Reform Through Federal Incentives

**Overview**  

From 2009 to 2023, many U.S. metropolitan areas faced widening gaps between housing demand and supply. Rent burdens peaked around 2011–2012, with households spending over 30% of income on rent. Yet, regions with stronger construction activity managed to stabilize or lower rent costs, while cities like New York and San Francisco continue to struggle with affordability. These trends highlight how YIMBY-oriented housing policies can enhance both affordability and economic resilience.


**Identifying Sponsors** 

- Primary Sponsor– Salisbury, MD:
A clear YIMBY success story. Salisbury’s strong housing growth (+18%) and moderate rent-to-income ratio (~25%) demonstrate how regional investment and zoning flexibility can improve affordability and accommodate population increases.

- Co-Sponsor – New York City, NY:
A high-demand but constrained housing market. NYC’s rent burden remains elevated (~36%), while housing permit activity trails behind population growth. These conditions make it an ideal contrast case for advocating federal incentives that reward higher permitting activity.

**Local Impact and Support**

This legislation would help both types of cities.  

- For growing, high-rent cities, the bill provides federal matching grantsto expand infrastructure and housing capacity, ensuring new development keeps pace with population growth.  

- For more affordable but slower-growing metros, it offers incentives for smart infill development, helping maintain economic vitality while preventing future shortages.

**Supporting Interest Groups**

- Construction and Building Trade Workers:

This bill directly benefits construction-related jobs by boosting the number of permitted housing projects nationwide. An estimated 10–15% increase in annual building activity could create thousands of stable, skilled-labor positions. As local governments expand development, these workers will see more consistent employment and higher wages.

- Teachers and Healthcare Employees:

In many metro areas, teachers, nurses, and first responders spend over one-third of their income on rent. By lowering rent burdens toward the national average (~25%), this policy would improve financial stability and help communities retain essential workers. Stable housing supports long-term workforce reliability and community engagement.

**Metrics for Evaluation**

Two primary metrics are recommended for tracking progress:

- Rent Burden Index – Measures the share of income spent on rent, standardized so that 100 equals the national average in the first year. A declining index signals improved affordability.  
- Housing Growth Index– Combines instantaneous (permits per 1,000 residents) and rate-based (permits relative to population growth) measures. A higher score reflects stronger housing expansion relative to demand.

**Conclusion**

This bill would empower cities to accelerate housing construction, stabilize rents, and sustain economic growth. By linking federal funding to measurable outcomes in affordability and housing expansion, the program aligns local incentives with national goals for equitable, sustainable urban development.
:::

## Extra Credit Opportunity #01: Relationship Diagram

### Relationship Diagram

The relationship diagram below shows how the main datasets in this project are connected. Each table—such as Income, Rent, Population, Households, and Permits—shares common keys (GEOID and year), which allow them to be joined for analysis. This structure makes it possible to study how population, income, and housing growth interact to influence affordability across different metropolitan areas.

![](relationship_diagram.png)

## Extra Credit #02: Highlighting Important Units in a Spaghetti Plot

### It was completed in Task 3 (Average Household Size Over Time).

